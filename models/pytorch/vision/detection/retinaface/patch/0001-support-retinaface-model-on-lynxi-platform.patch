From 9bce775d2c74cff3d8b0ef8a2f66656e664e1c4c Mon Sep 17 00:00:00 2001
From: "shuangquan.he" <shuangquan.he@lynxi.com>
Date: Thu, 23 Jun 2022 13:40:34 +0800
Subject: [PATCH] support retinaface model on lynxi platform

---
 detect.py            |  24 +++++--
 models/retinaface.py |   4 +-
 test_lynxi.py        | 187 +++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 208 insertions(+), 7 deletions(-)
 mode change 100644 => 100755 models/retinaface.py
 create mode 100755 test_lynxi.py

diff --git a/detect.py b/detect.py
index 2e82240..dab2e97 100755
--- a/detect.py
+++ b/detect.py
@@ -11,6 +11,9 @@ import cv2
 from models.retinaface import RetinaFace
 from utils.box_utils import decode, decode_landm
 import time
+import pickle
+
+TOP = os.environ['TOP']
 
 parser = argparse.ArgumentParser(description='Retinaface')
 
@@ -63,6 +66,11 @@ def load_model(model, pretrained_path, load_to_cpu):
     return model
 
 
+def dumpPickleAbs(data, absFile=None):
+    with open(absFile, 'wb') as fin:
+        pickle.dump(data, fin)
+
+
 if __name__ == '__main__':
     torch.set_grad_enabled(False)
     cfg = None
@@ -74,6 +82,9 @@ if __name__ == '__main__':
     net = RetinaFace(cfg=cfg, phase = 'test')
     net = load_model(net, args.trained_model, args.cpu)
     net.eval()
+
+    targetModelFile = "{}/curve/target_net.pth".format(TOP)
+    torch.save(net, targetModelFile)
     print('Finished loading model!')
     print(net)
     cudnn.benchmark = True
@@ -83,8 +94,8 @@ if __name__ == '__main__':
     resize = 1
 
     # testing begin
-    for i in range(100):
-        image_path = "./curve/test.jpg"
+    for i in range(1):
+        image_path = "./curve/img_640_640.jpg"
         img_raw = cv2.imread(image_path, cv2.IMREAD_COLOR)
 
         img = np.float32(img_raw)
@@ -98,8 +109,12 @@ if __name__ == '__main__':
         scale = scale.to(device)
 
         tic = time.time()
+        dumpPickleAbs(img, "{}/curve/input.bin".format(TOP))
         loc, conf, landms = net(img)  # forward pass
         print('net forward time: {:.4f}'.format(time.time() - tic))
+        dumpPickleAbs([loc.numpy(), conf.numpy(),
+                       landms.numpy()],
+                      "{}/curve/output_target.bin".format(TOP))
 
         priorbox = PriorBox(cfg, image_size=(im_height, im_width))
         priors = priorbox.forward()
@@ -162,7 +177,4 @@ if __name__ == '__main__':
                 cv2.circle(img_raw, (b[11], b[12]), 1, (0, 255, 0), 4)
                 cv2.circle(img_raw, (b[13], b[14]), 1, (255, 0, 0), 4)
             # save image
-
-            name = "test.jpg"
-            cv2.imwrite(name, img_raw)
-
+            cv2.imwrite("{}/curve/test.jpg".format(TOP), img_raw)
diff --git a/models/retinaface.py b/models/retinaface.py
old mode 100644
new mode 100755
index d530bd8..ab92e8a
--- a/models/retinaface.py
+++ b/models/retinaface.py
@@ -57,7 +57,9 @@ class RetinaFace(nn.Module):
         if cfg['name'] == 'mobilenet0.25':
             backbone = MobileNetV1()
             if cfg['pretrain']:
-                checkpoint = torch.load("./weights/mobilenetV1X0.25_pretrain.tar", map_location=torch.device('cpu'))
+                checkpoint = torch.load(
+                    "./curve/mobilenetV1X0.25_pretrain.tar",
+                    map_location=torch.device('cpu'))
                 from collections import OrderedDict
                 new_state_dict = OrderedDict()
                 for k, v in checkpoint['state_dict'].items():
diff --git a/test_lynxi.py b/test_lynxi.py
new file mode 100755
index 0000000..943b2bc
--- /dev/null
+++ b/test_lynxi.py
@@ -0,0 +1,187 @@
+from genericpath import exists
+import os
+import sys
+import pickle
+import argparse
+import lyngor
+import numpy as np
+import torch
+
+TOP = os.environ['TOP']
+
+parser = argparse.ArgumentParser()
+parser.add_argument('-m', '--mode', default='null', type=str)
+parser.add_argument('-p', '--path', default='null', type=str)
+parser.add_argument('-i', '--imgdump', default='null', type=str)
+
+
+def pmodel_inletv3(modelType="Pytorch",
+                   modelFile="",
+                   buildType="apu",
+                   inputPart=None,
+                   outputPart=None,
+                   outputPath=''):
+    '''
+    modelType: 'Tensorflow','Keras','Keras_tf','MXNet','Caffe','Pytorch','ONNX'
+    modelFile: 离线模型的相关路径
+    buildType:
+        cpus: cpu模拟推理 (target='cpu', cpu_arch="x86", cc="g++")
+        apus: apu模拟推理 (target='apu', cpu_arch="x86", cc="g++")
+        apu:  apu板卡推理 (target='apu')
+    '''
+    print("[pmodel_inlet] lyngor version:{}, lyngor path:{}".format(
+        lyngor.version, lyngor))
+    if not os.path.exists(modelFile):
+        print("model file not exists.")
+
+    offlineModel = lyngor.DLModel()
+    offlineModel.load(modelFile,
+                      model_type=modelType,
+                      inputs_dict=inputPart,
+                      outputs=outputPart)
+
+    if buildType == "cpus":
+        offlineBuilder = lyngor.Builder(target='cpu',
+                                        cpu_arch="x86",
+                                        cc="g++",
+                                        is_map=True)
+    elif buildType == "apus":
+        offlineBuilder = lyngor.Builder(target='apu',
+                                        cpu_arch="x86",
+                                        cc="g++",
+                                        is_map=True)
+    elif buildType == "apu":
+        offlineBuilder = lyngor.Builder(target='apu', is_map=True)
+    else:
+        print("cannot support the buildType")
+    r_engine = offlineBuilder.build(offlineModel.graph,
+                                    offlineModel.params,
+                                    out_path=outputPath)
+
+
+def funcModel(targetFile: str):
+    if not os.path.exists(targetFile):
+        sys.exit(1)
+
+    myselfModelFile = "{}/curve/model_myself".format(TOP)
+    pmodel_inletv3(modelType="Pytorch",
+                   modelFile=targetFile,
+                   buildType='apu',
+                   inputPart={'input0': (1, 3, 640, 640)},
+                   outputPart=None,
+                   outputPath=myselfModelFile)
+    pass
+
+
+def loadPickle(binFile):
+    if not os.path.exists(binFile):
+        print("warn: {} not exists".format(binFile))
+        return None
+    with open(binFile, "rb") as fin:
+        ret = pickle.load(fin)
+    return ret
+
+
+def modelByRuntime(lynModelPath=None, input=None):
+    input = loadPickle(input)
+    if isinstance(input, torch.Tensor):
+        input = input.numpy()
+    input = np.ascontiguousarray(input)
+
+    modelLyn = lyngor.loader.load(path=lynModelPath, device=0, PDT=False)
+    modelLyn.run(data_format='numpy', **{"input0": input})
+    ret = modelLyn.get_output(data_format='numpy')
+    print("len ret: {}".format(len(ret)))
+    for i in range(len(ret)):
+        print("{}: {}".format(i, ret[i].shape))
+
+    return ret
+
+
+def measure_mse(list_target, list_compare, identifier):
+    '''
+    均方误差(MSE)是各数据偏离真实值差值的平方和的平均数
+    list_target  真实模型的推理结果
+    list_compare 编译模型的推理结果
+    '''
+    if not (isinstance(list_target, np.ndarray)
+            and isinstance(list_compare, np.ndarray)):
+        return None
+    ret = np.sum((np.float32(list_compare) - np.float32(list_target))**
+                 2) / len(list_target)
+    print("[均方误差MSE] 分段_{}: {}".format(identifier, ret))
+    return ret
+
+
+def measure_error_rate(list_target, list_compare, identifier):
+    '''
+    误差率：预测值相对真实值的误差值
+    list_target  真实模型的推理结果
+    list_compare 编译模型的推理结果
+    '''
+    ret = np.sqrt(np.sum((np.float32(list_compare) - np.float32(list_target))**2)) / \
+        np.sqrt(np.sum(np.float32(list_target)**2))
+    print("[误差率] 分段_{}: {}".format(identifier, ret))
+    return ret
+
+
+def measure_inlet(data_target, data_lynpy):
+    '''
+    data_target: [np0, np1, ...]
+    data_lynpy: [np0, np1, ...]
+    '''
+    # if not (data_target and data_lynpy):
+    #     print("warn: maybe none for input")
+    #     return None
+
+    # 多输出的分段评估
+    for index in range(len(data_target)):
+        data_flat_caffe = data_target[index].flatten()
+        data_flat_lynpy = data_lynpy[index].flatten()
+        measure_mse(data_flat_caffe, data_flat_lynpy, "{}".format(index))
+        measure_error_rate(data_flat_caffe, data_flat_lynpy,
+                           "{}".format(index))
+
+    # 多输出的整体评估
+    '''
+    data_caffe[0].numpy().flatten() pytorch -> numpy
+    tempTarget = np.concatenate(
+        (data_target[0].flatten(), data_target[1].flatten(),
+         data_target[2].flatten()),
+        axis=0)
+    tempMyself = np.concatenate(
+        (data_lynpy[0].flatten(), data_lynpy[1].flatten(),
+         data_lynpy[2].flatten()),
+        axis=0)
+    '''
+
+    tempTarget = np.concatenate([it.flatten() for it in data_target], axis=0)
+    tempMyself = np.concatenate([it.flatten() for it in data_lynpy], axis=0)
+    measure_mse(tempTarget, tempMyself, "整体")
+    measure_error_rate(tempTarget, tempMyself, "整体")
+
+
+def funcRun(lynxiFile: str, imgFile):
+    if not (os.path.exists(lynxiFile) or os.path.exists(imgFile)):
+        sys.exit(1)
+
+    ret = modelByRuntime("{}/Net_0".format(lynxiFile), imgFile)
+    tempFile = "{}/curve/output_myself.bin".format(TOP)
+    with open(tempFile, 'wb') as fin:
+        pickle.dump(ret, fin)
+    pass
+
+
+if __name__ == '__main__':
+    args = parser.parse_args()
+
+    if args.mode == "build":
+        funcModel(args.path)
+    elif args.mode == "run":
+        funcRun(args.path, args.imgdump)
+
+        measure_inlet(loadPickle("{}/curve/output_target.bin".format(TOP)),
+                      loadPickle("{}/curve/output_myself.bin".format(TOP)))
+    else:
+        print("error, cannot support the option")
+    pass
\ No newline at end of file
-- 
2.7.4

